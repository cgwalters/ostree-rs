// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

#[cfg(any(feature = "v2020_2", feature = "dox"))]
use gio;
#[cfg(any(feature = "v2020_2", feature = "dox"))]
use glib;
use glib::object::IsA;
use glib::translate::*;
#[cfg(any(feature = "v2020_2", feature = "dox"))]
use glib::GString;
use ostree_sys;
use std::fmt;
#[cfg(any(feature = "v2020_2", feature = "dox"))]
use std::ptr;
#[cfg(any(feature = "v2020_2", feature = "dox"))]
use Repo;

glib_wrapper! {
    pub struct Sign(Interface<ostree_sys::OstreeSign>);

    match fn {
        get_type => || ostree_sys::ostree_sign_get_type(),
    }
}

impl Sign {
    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    pub fn get_all() -> Vec<Sign> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ostree_sys::ostree_sign_get_all())
        }
    }

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    pub fn get_by_name(name: &str) -> Result<Sign, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ostree_sys::ostree_sign_get_by_name(name.to_glib_none().0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }
}

pub const NONE_SIGN: Option<&Sign> = None;

pub trait SignExt: 'static {
    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn add_pk(&self, public_key: &glib::Variant) -> Result<(), glib::Error>;

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn clear_keys(&self) -> Result<(), glib::Error>;

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn commit<P: IsA<gio::Cancellable>>(&self, repo: &Repo, commit_checksum: &str, cancellable: Option<&P>) -> Result<(), glib::Error>;

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn commit_verify<P: IsA<gio::Cancellable>>(&self, repo: &Repo, commit_checksum: &str, cancellable: Option<&P>) -> Result<Option<GString>, glib::Error>;

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn data<P: IsA<gio::Cancellable>>(&self, data: &glib::Bytes, signature: &glib::Bytes, cancellable: Option<&P>) -> Result<(), glib::Error>;

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn data_verify(&self, data: &glib::Bytes, signatures: &glib::Variant) -> Result<Option<GString>, glib::Error>;

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn get_name(&self) -> Option<GString>;

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn load_pk(&self, options: &glib::Variant) -> Result<(), glib::Error>;

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn metadata_format(&self) -> Option<GString>;

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn metadata_key(&self) -> Option<GString>;

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn set_pk(&self, public_key: &glib::Variant) -> Result<(), glib::Error>;

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn set_sk(&self, secret_key: &glib::Variant) -> Result<(), glib::Error>;

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn summary<P: IsA<gio::Cancellable>>(&self, repo: &Repo, keys: &glib::Variant, cancellable: Option<&P>) -> Result<(), glib::Error>;
}

impl<O: IsA<Sign>> SignExt for O {
    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn add_pk(&self, public_key: &glib::Variant) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = ostree_sys::ostree_sign_add_pk(self.as_ref().to_glib_none().0, public_key.to_glib_none().0, &mut error);
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn clear_keys(&self) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = ostree_sys::ostree_sign_clear_keys(self.as_ref().to_glib_none().0, &mut error);
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn commit<P: IsA<gio::Cancellable>>(&self, repo: &Repo, commit_checksum: &str, cancellable: Option<&P>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = ostree_sys::ostree_sign_commit(self.as_ref().to_glib_none().0, repo.to_glib_none().0, commit_checksum.to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn commit_verify<P: IsA<gio::Cancellable>>(&self, repo: &Repo, commit_checksum: &str, cancellable: Option<&P>) -> Result<Option<GString>, glib::Error> {
        unsafe {
            let mut out_success_message = ptr::null_mut();
            let mut error = ptr::null_mut();
            let _ = ostree_sys::ostree_sign_commit_verify(self.as_ref().to_glib_none().0, repo.to_glib_none().0, commit_checksum.to_glib_none().0, &mut out_success_message, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            if error.is_null() { Ok(from_glib_full(out_success_message)) } else { Err(from_glib_full(error)) }
        }
    }

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn data<P: IsA<gio::Cancellable>>(&self, data: &glib::Bytes, signature: &glib::Bytes, cancellable: Option<&P>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = ostree_sys::ostree_sign_data(self.as_ref().to_glib_none().0, data.to_glib_none().0, signature.to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn data_verify(&self, data: &glib::Bytes, signatures: &glib::Variant) -> Result<Option<GString>, glib::Error> {
        unsafe {
            let mut out_success_message = ptr::null_mut();
            let mut error = ptr::null_mut();
            let _ = ostree_sys::ostree_sign_data_verify(self.as_ref().to_glib_none().0, data.to_glib_none().0, signatures.to_glib_none().0, &mut out_success_message, &mut error);
            if error.is_null() { Ok(from_glib_full(out_success_message)) } else { Err(from_glib_full(error)) }
        }
    }

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn get_name(&self) -> Option<GString> {
        unsafe {
            from_glib_none(ostree_sys::ostree_sign_get_name(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn load_pk(&self, options: &glib::Variant) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = ostree_sys::ostree_sign_load_pk(self.as_ref().to_glib_none().0, options.to_glib_none().0, &mut error);
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn metadata_format(&self) -> Option<GString> {
        unsafe {
            from_glib_none(ostree_sys::ostree_sign_metadata_format(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn metadata_key(&self) -> Option<GString> {
        unsafe {
            from_glib_none(ostree_sys::ostree_sign_metadata_key(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn set_pk(&self, public_key: &glib::Variant) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = ostree_sys::ostree_sign_set_pk(self.as_ref().to_glib_none().0, public_key.to_glib_none().0, &mut error);
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn set_sk(&self, secret_key: &glib::Variant) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = ostree_sys::ostree_sign_set_sk(self.as_ref().to_glib_none().0, secret_key.to_glib_none().0, &mut error);
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[cfg(any(feature = "v2020_2", feature = "dox"))]
    fn summary<P: IsA<gio::Cancellable>>(&self, repo: &Repo, keys: &glib::Variant, cancellable: Option<&P>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let _ = ostree_sys::ostree_sign_summary(self.as_ref().to_glib_none().0, repo.to_glib_none().0, keys.to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }
}

impl fmt::Display for Sign {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Sign")
    }
}
